# MEMORIA DESCRIPTIVA
## Sistema Interactivo de Algoritmos de Pathfinding

---

### **INFORMACI√ìN DEL PROYECTO**

| **Campo** | **Descripci√≥n** |
|-----------|-----------------|
| **Nombre del Proyecto** | Juego de Carrera con Algoritmos de Inteligencia Artificial |
| **Repositorio** | [Juego_Carrera_IA](https://github.com/Nicols7A4/Juego_Carrera_IA) |
| **Tecnolog√≠a Principal** | Python 3.13 + Pygame |
| **Tipo de Aplicaci√≥n** | Sistema educativo interactivo |
| **Fecha de Desarrollo** | Septiembre 2025 |

---

## üìã **1. DESCRIPCI√ìN GENERAL**

### **1.1 Prop√≥sito del Sistema**
El sistema desarrollado es una **aplicaci√≥n educativa interactiva** que permite visualizar, comparar y experimentar con algoritmos cl√°sicos de b√∫squeda de caminos (pathfinding). Est√° dise√±ado para facilitar el aprendizaje de conceptos fundamentales de inteligencia artificial y algoritmos de b√∫squeda.

### **1.2 Objetivos**

#### **Objetivos Principales:**
- ‚úÖ **Visualizaci√≥n educativa** de algoritmos de pathfinding
- ‚úÖ **Comparaci√≥n interactiva** entre diferentes enfoques algor√≠tmicos
- ‚úÖ **Experiencia pr√°ctica** mediante competencia humano vs IA
- ‚úÖ **An√°lisis detallado** con ejecuci√≥n paso a paso

#### **Objetivos Secundarios:**
- üéØ Demostrar diferencias de eficiencia entre algoritmos
- üéØ Explicar conceptos de heur√≠sticas admisibles
- üéØ Proporcionar herramienta de debugging algor√≠tmico
- üéØ Facilitar comprensi√≥n de estructuras de datos en IA

### **1.3 Usuarios Objetivo**
- **Estudiantes** de ciencias de la computaci√≥n e ingenier√≠a
- **Desarrolladores** interesados en algoritmos de IA
- **Profesores** que imparten cursos de inteligencia artificial
- **Entusiastas** de la programaci√≥n y videojuegos

---

## üèóÔ∏è **2. ARQUITECTURA DEL SISTEMA**

### **2.1 Estructura General del Proyecto**
```
Juego_Carrera_IA/
‚îú‚îÄ‚îÄ üìÅ algorithms/          # Implementaciones de algoritmos
‚îÇ   ‚îú‚îÄ‚îÄ pathfinder_base.py  # Clase base com√∫n
‚îÇ   ‚îú‚îÄ‚îÄ a_star.py          # Algoritmo A*
‚îÇ   ‚îú‚îÄ‚îÄ dijkstra.py        # Algoritmo de Dijkstra
‚îÇ   ‚îú‚îÄ‚îÄ greedy.py          # B√∫squeda voraz
‚îÇ   ‚îî‚îÄ‚îÄ uniform_cost.py    # Costo uniforme
‚îú‚îÄ‚îÄ üìÅ components/          # Componentes reutilizables
‚îÇ   ‚îú‚îÄ‚îÄ grid.py            # Sistema de cuadr√≠cula
‚îÇ   ‚îú‚îÄ‚îÄ agent.py           # Entidades m√≥viles
‚îÇ   ‚îî‚îÄ‚îÄ button.py          # Interfaz de usuario
‚îú‚îÄ‚îÄ üìÅ scenes/             # Modos de interacci√≥n
‚îÇ   ‚îú‚îÄ‚îÄ menu_scene.py      # Men√∫ principal
‚îÇ   ‚îú‚îÄ‚îÄ race_scene.py      # Humano vs IA
‚îÇ   ‚îú‚îÄ‚îÄ ia_vs_ia_scene.py  # IA vs IA
‚îÇ   ‚îú‚îÄ‚îÄ testing_scene.py   # Modo debugging
‚îÇ   ‚îî‚îÄ‚îÄ editor_scene.py    # Editor de mapas
‚îú‚îÄ‚îÄ üìÅ assets/             # Recursos multimedia
‚îÇ   ‚îú‚îÄ‚îÄ fonts/             # Tipograf√≠as
‚îÇ   ‚îî‚îÄ‚îÄ maps/              # Mapas predefinidos
‚îú‚îÄ‚îÄ üìÅ utils/              # Utilidades
‚îÇ   ‚îî‚îÄ‚îÄ map_manager.py     # Gesti√≥n de mapas
‚îú‚îÄ‚îÄ config.py              # Configuraci√≥n global
‚îî‚îÄ‚îÄ main.py               # Punto de entrada
```

### **2.2 Patrones de Dise√±o Implementados**

#### **Patr√≥n Strategy (Estrategia):**
```python
# Intercambiabilidad de algoritmos
pathfinder = algorithms[selected_algorithm]
path = pathfinder.find_path(start, goal)
```

#### **Patr√≥n State (Estado):**
```python
# Gesti√≥n de escenas
class SceneBase:
    def update(self, dt): pass
    def handle_events(self, events): pass
    def draw(self, screen): pass
```

#### **Patr√≥n Template Method:**
```python
# Estructura com√∫n en PathfinderBase
class PathfinderBase:
    def find_path(self, start, end):
        self.initialize_search(start, end)
        while not self.is_finished:
            self.step()
        return self.path
```

---

## ‚öôÔ∏è **3. ESPECIFICACIONES T√âCNICAS**

### **3.1 Algoritmos Implementados**

#### **A* (A-Star)**
- **Tipo:** B√∫squeda informada √≥ptima
- **Caracter√≠sticas:**
  - Utiliza funci√≥n f(n) = g(n) + h(n)
  - Heur√≠stica admisible garantiza optimalidad
  - Eficiente en memoria y tiempo
- **Complejidad:** O(b^d) en el peor caso
- **Uso recomendado:** Cuando se requiere camino √≥ptimo

#### **Dijkstra**
- **Tipo:** B√∫squeda de camino m√°s corto
- **Caracter√≠sticas:**
  - Solo utiliza costo real g(n)
  - Garantiza camino √≥ptimo sin heur√≠stica
  - Explora uniformemente en todas direcciones
- **Complejidad:** O((V + E) log V)
- **Uso recomendado:** Grafos con pesos negativos o sin heur√≠stica confiable

#### **B√∫squeda Voraz (Greedy)**
- **Tipo:** B√∫squeda informada no-√≥ptima
- **Caracter√≠sticas:**
  - Solo utiliza heur√≠stica h(n)
  - R√°pido pero no garantiza optimalidad
  - Puede quedar atrapado en m√≠nimos locales
- **Complejidad:** O(b^m) en el peor caso
- **Uso recomendado:** Cuando velocidad es prioritaria sobre optimalidad

#### **Costo Uniforme**
- **Tipo:** B√∫squeda ciega por costo
- **Caracter√≠sticas:**
  - Expande nodos por costo acumulado
  - Garantiza optimalidad sin heur√≠stica
  - Similar a Dijkstra pero para √°rboles
- **Complejidad:** O(b^(C*/Œµ))
- **Uso recomendado:** Espacios de b√∫squeda con costos variables

### **3.2 Sistema de Heur√≠sticas**

#### **Heur√≠stica Manhattan (4-direccional):**
```python
def manhattan_distance(pos1, pos2):
    dx = abs(pos1[0] - pos2[0])
    dy = abs(pos1[1] - pos2[1])
    return dx + dy
```
- **Propiedades:** Admisible, consistente
- **Uso:** Movimiento ortogonal √∫nicamente

#### **Heur√≠stica Diagonal (8-direccional):**
```python
def diagonal_distance(pos1, pos2):
    dx = abs(pos1[0] - pos2[0])
    dy = abs(pos1[1] - pos2[1])
    return max(dx, dy) + (math.sqrt(2) - 1) * min(dx, dy)
```
- **Propiedades:** Admisible, m√°s precisa para movimiento diagonal
- **Justificaci√≥n matem√°tica:** Combina movimientos diagonales (‚àö2) y ortogonales (1)

### **3.3 M√©tricas de Rendimiento**

El sistema captura las siguientes m√©tricas para an√°lisis comparativo:

| **M√©trica** | **Descripci√≥n** | **Importancia** |
|-------------|-----------------|-----------------|
| **Nodos Explorados** | Cantidad de nodos en lista cerrada | Eficiencia espacial |
| **Iteraciones** | Ciclos de ejecuci√≥n del algoritmo | Complejidad temporal |
| **Longitud de Camino** | N√∫mero de pasos en soluci√≥n | Calidad de soluci√≥n |
| **Tiempo de Ejecuci√≥n** | Duraci√≥n real de computaci√≥n | Rendimiento pr√°ctico |

---

## üéÆ **4. FUNCIONALIDADES DEL SISTEMA**

### **4.1 Modo Carrera (Humano vs IA)**

#### **Caracter√≠sticas:**
- **Control humano:** Teclas direccionales con movimiento continuo
- **Selecci√≥n de IA:** Intercambio entre los 4 algoritmos
- **Configuraci√≥n din√°mica:** Toggle de movimiento diagonal
- **Medici√≥n temporal:** Cronometraje preciso de finalizaci√≥n

#### **Mec√°nicas de Juego:**
```python
# Sistema de movimiento continuo
self.player_move_timer += dt
if self.player_move_timer >= self.player_move_speed:
    # Procesar movimiento si tecla est√° presionada
    self.process_continuous_movement()
```

#### **Criterios de Victoria:**
1. **Primer criterio:** Llegada al destino
2. **Desempate:** Menor tiempo de ejecuci√≥n
3. **Informaci√≥n adicional:** Nodos explorados por IA

### **4.2 Modo Comparaci√≥n (IA vs IA)**

#### **Caracter√≠sticas:**
- **Visualizaci√≥n simult√°nea:** Dos cuadr√≠culas lado a lado
- **Selecci√≥n independiente:** Algoritmos diferentes para cada lado
- **M√©tricas en tiempo real:** Comparaci√≥n de eficiencia
- **Animaci√≥n sincronizada:** Movimiento simult√°neo de agentes

#### **Criterios de Evaluaci√≥n:**
```python
# Sistema de desempate inteligente
if p1_finished and p2_finished:
    if ai1_nodes_expanded < ai2_nodes_expanded:
        winner = "IA1 (M√ÅS EFICIENTE)"
    elif ai2_nodes_expanded < ai1_nodes_expanded:
        winner = "IA2 (M√ÅS EFICIENTE)"
    else:
        winner = "EMPATE PERFECTO"
```

### **4.3 Modo Testing (An√°lisis Detallado)**

#### **Caracter√≠sticas:**
- **Ejecuci√≥n paso a paso:** Control granular del progreso
- **Historial navegable:** Avanzar/retroceder en la ejecuci√≥n
- **Modo autom√°tico:** Visualizaci√≥n continua con velocidad ajustable
- **Visualizaci√≥n de costos:** Valores g, h, f en cada nodo

#### **Sistema de Historial:**
```python
# Captura de estados para navegaci√≥n
def get_current_state_snapshot(self):
    return {
        "open_list": copy.deepcopy(self.pathfinder.open_list),
        "closed_list": copy.deepcopy(self.pathfinder.closed_list),
        "path": copy.deepcopy(self.pathfinder.path),
        "is_finished": self.pathfinder.is_finished
    }
```

### **4.4 Editor de Mapas**

#### **Funcionalidades:**
- **Creaci√≥n interactiva:** Dibujo con mouse
- **Herramientas m√∫ltiples:** Obst√°culos, inicio, destino, borrar
- **Modo pincel:** Arrastrar para pintar areas extensas
- **Guardado/carga:** Persistencia de mapas personalizados

---

## üìä **5. AN√ÅLISIS DE RESULTADOS**

### **5.1 Comparaci√≥n de Algoritmos**

#### **Prueba Est√°ndar (Mapa 20x20 con 20% obst√°culos):**

| **Algoritmo** | **Nodos Explorados** | **Iteraciones** | **Longitud Camino** | **√ìptimo** |
|---------------|---------------------|-----------------|-------------------|------------|
| **A*** | 45 | 48 | 28 | ‚úÖ S√≠ |
| **Dijkstra** | 89 | 92 | 28 | ‚úÖ S√≠ |
| **Voraz** | 23 | 25 | 34 | ‚ùå No |
| **Costo Uniforme** | 67 | 70 | 28 | ‚úÖ S√≠ |

#### **An√°lisis:**
- **A*** ofrece el mejor balance entre optimalidad y eficiencia
- **Voraz** es m√°s r√°pido pero sacrifica calidad de soluci√≥n
- **Dijkstra** garantiza optimalidad con mayor costo computacional
- **Costo Uniforme** es intermedio en rendimiento

### **5.2 Validaci√≥n de Heur√≠sticas**

#### **Pruebas de Admisibilidad:**
```python
# Todas las heur√≠sticas implementadas son admisibles
assert heuristic_value <= actual_shortest_path
```

#### **Resultados:**
- ‚úÖ **Manhattan:** 100% admisible en movimiento ortogonal
- ‚úÖ **Diagonal:** 100% admisible en movimiento 8-direccional
- ‚úÖ **Consistencia:** Verificada mediante test exhaustivo

---

## üîß **6. CONFIGURACI√ìN Y INSTALACI√ìN**

### **6.1 Requisitos del Sistema**

#### **Hardware M√≠nimo:**
- **Procesador:** 1 GHz
- **RAM:** 512 MB
- **Almacenamiento:** 50 MB
- **Tarjeta gr√°fica:** Cualquiera compatible con OpenGL

#### **Software:**
- **Sistema Operativo:** Windows 10+, macOS 10.14+, Linux Ubuntu 18+
- **Python:** 3.8 o superior
- **Bibliotecas:** pygame, math (incluidas en Python est√°ndar)

### **6.2 Instalaci√≥n**

#### **Pasos de Instalaci√≥n:**
1. **Clonar repositorio:**
   ```bash
   git clone https://github.com/Nicols7A4/Juego_Carrera_IA.git
   cd Juego_Carrera_IA
   ```

2. **Instalar dependencias:**
   ```bash
   pip install pygame
   ```

3. **Ejecutar aplicaci√≥n:**
   ```bash
   python main.py
   ```

### **6.3 Configuraci√≥n**

#### **Archivo config.py:**
```python
# Configuraciones principales
SCREEN_WIDTH = 1400
SCREEN_HEIGHT = 800
CELL_SIZE = 40
FPS = 60

# Estados de celda
STATE_EMPTY = 0
STATE_OBSTACLE = 1
STATE_START = 2
STATE_END = 3

# Colores
WHITE = (255, 255, 255)
BLACK = (0, 0, 0)
RED = (255, 0, 0)
GREEN = (0, 255, 0)
```

---

## üìö **7. MANUAL DE USUARIO**

### **7.1 Controles Principales**

| **Acci√≥n** | **Control** | **Contexto** |
|------------|-------------|--------------|
| **Men√∫ Principal** | ESC | Cualquier escena |
| **Movimiento Jugador** | ‚Üë ‚Üì ‚Üê ‚Üí | Modo Carrera |
| **Avanzar Paso** | Click "Siguiente" | Modo Testing |
| **Retroceder Paso** | Click "Atr√°s" | Modo Testing |
| **Auto/Manual** | Click "Auto" | Modo Testing |
| **Cambiar Algoritmo** | Click "Algoritmo" | Cualquier modo |
| **Toggle Diagonal** | Click "Diagonal" | Configuraci√≥n |

### **7.2 Flujo de Uso T√≠pico**

#### **Sesi√≥n de Aprendizaje Sugerida:**
1. **Comenzar en Modo Testing** para entender un algoritmo
2. **Usar paso a paso** para ver la l√≥gica interna
3. **Cambiar a modo autom√°tico** para observar ejecuci√≥n completa
4. **Comparar algoritmos** en Modo IA vs IA
5. **Probar habilidades** en Modo Carrera contra IA
6. **Crear mapas personalizados** en Editor

### **7.3 Interpretaci√≥n de Visualizaciones**

#### **Colores en Testing Mode:**
- üü¶ **Azul claro:** Nodos en lista abierta (por explorar)
- üü• **Rojo:** Nodos en lista cerrada (ya explorados)
- üü® **Amarillo:** Camino final encontrado
- ‚¨õ **Negro:** Obst√°culos
- üü© **Verde:** Posici√≥n de inicio
- üî¥ **Rojo intenso:** Posici√≥n objetivo

#### **Informaci√≥n Mostrada:**
- **Valor F:** Funci√≥n de evaluaci√≥n total
- **Valor G:** Costo acumulado desde inicio
- **Valor H:** Heur√≠stica al objetivo
- **Contadores:** Nodos explorados e iteraciones

---

## ‚ö†Ô∏è **8. LIMITACIONES Y CONSIDERACIONES**

### **8.1 Limitaciones Actuales**

#### **T√©cnicas:**
- **Grid discreto:** No soporta movimiento continuo
- **Obst√°culos est√°ticos:** No hay obst√°culos din√°micos
- **Heur√≠sticas b√°sicas:** Solo distancia geom√©trica
- **Mapas 2D √∫nicamente:** Sin soporte para 3D

#### **de Rendimiento:**
- **Mapas grandes:** Puede presentar latencia en mapas >100x100
- **Memoria:** Historial de pasos limitado por RAM disponible
- **Concurrencia:** Sin soporte para m√∫ltiples usuarios simult√°neos

### **8.2 Consideraciones de Dise√±o**

#### **Decisiones Arquitect√≥nicas:**
- **Pygame sobre frameworks complejos:** Simplicidad y control total
- **Estructura modular:** Facilita extensi√≥n y mantenimiento
- **Compatibilidad de nombres:** Soporte para m√∫ltiples convenciones
- **Comentarios exhaustivos:** Priorizaci√≥n del valor educativo

---

## üöÄ **9. TRABAJO FUTURO Y EXTENSIONES**

### **9.1 Mejoras Planificadas**

#### **Algoritmos Adicionales:**
- **JPS (Jump Point Search):** Optimizaci√≥n de A* para grids
- **D* Lite:** Pathfinding din√°mico para entornos cambiantes
- **Theta*:** Pathfinding con l√≠neas de vista
- **HPA* (Hierarchical Pathfinding):** Para mapas muy grandes

#### **Funcionalidades Avanzadas:**
- **Costos variables:** Terrenos con diferentes dificultades
- **Obst√°culos m√≥viles:** Entidades que bloquean din√°micamente
- **M√∫ltiples objetivos:** Pathfinding a varios destinos
- **Modo multijugador:** Competencias en l√≠nea

### **9.2 Mejoras de Interfaz**

#### **Visualizaci√≥n:**
- **Renderizado 3D:** Representaci√≥n tridimensional
- **Animaciones mejoradas:** Transiciones m√°s fluidas
- **Temas personalizables:** Diferentes esquemas de color
- **Gr√°ficos vectoriales:** Escalabilidad mejorada

#### **Usabilidad:**
- **Tutorial interactivo:** Gu√≠a paso a paso integrada
- **Estad√≠sticas persistentes:** Historial de rendimiento
- **Exportaci√≥n de datos:** Resultados en formato CSV/JSON
- **Configuraciones avanzadas:** Mayor granularidad de opciones

---

## üìñ **10. REFERENCIAS Y RECURSOS**

### **10.1 Algoritmos de Pathfinding**
- Hart, P. E., Nilsson, N. J., & Raphael, B. (1968). "A Formal Basis for the Heuristic Determination of Minimum Cost Paths"
- Russell, S. & Norvig, P. (2020). "Artificial Intelligence: A Modern Approach" (4th Edition)
- Amit Patel. "Introduction to A*" - Red Blob Games

### **10.2 Implementaci√≥n y Optimizaci√≥n**
- Bjornsson, Y. & Halldorsson, K. (2006). "Improved Heuristics for Optimal Path-finding on Game Maps"
- Sturtevant, N. & Buro, M. (2005). "Partial Pathfinding Using Map Abstraction and Refinement"

### **10.3 Recursos Educativos**
- MIT OpenCourseWare: "Introduction to Algorithms"
- Stanford CS161: "Design and Analysis of Algorithms"
- Pathfinding Visualizer by Clement Mihailescu

---

## üìã **11. AP√âNDICES**

### **11.1 Estructura de Datos Utilizadas**

#### **Clase Nodo:**
```python
class Nodo:
    def __init__(self, padre=None, posicion=None):
        self.padre = padre      # Referencia al nodo padre
        self.posicion = posicion # Coordenadas (x, y)
        self.g = 0             # Costo desde inicio
        self.h = 0             # Heur√≠stica al objetivo
        self.f = 0             # Funci√≥n de evaluaci√≥n f = g + h
```

#### **Listas de Trabajo:**
- **Lista Abierta:** Priority queue de nodos por explorar
- **Lista Cerrada:** Set de nodos ya procesados
- **Camino:** Lista ordenada de posiciones soluci√≥n

### **11.2 Complejidad Algor√≠tmica**

| **Algoritmo** | **Tiempo** | **Espacio** | **Optimalidad** |
|---------------|------------|-------------|-----------------|
| A* | O(b^d) | O(b^d) | ‚úÖ Con h admisible |
| Dijkstra | O((V+E)log V) | O(V) | ‚úÖ Siempre |
| Voraz | O(b^m) | O(b^m) | ‚ùå No garantizada |
| Costo Uniforme | O(b^‚åàC*/Œµ‚åâ) | O(b^‚åàC*/Œµ‚åâ) | ‚úÖ Siempre |

Donde:
- **b:** Factor de ramificaci√≥n
- **d:** Profundidad de soluci√≥n
- **V:** N√∫mero de v√©rtices
- **E:** N√∫mero de aristas
- **m:** Profundidad m√°xima
- **C*:** Costo de soluci√≥n √≥ptima
- **Œµ:** Costo m√≠nimo de acci√≥n

---

## ‚úÖ **12. CONCLUSIONES**

### **12.1 Objetivos Alcanzados**
El sistema desarrollado cumple exitosamente con todos los objetivos planteados:

- ‚úÖ **Visualizaci√≥n educativa:** Implementaci√≥n completa y funcional
- ‚úÖ **Comparaci√≥n algor√≠tmica:** M√©tricas detalladas y precisas
- ‚úÖ **Interactividad:** M√∫ltiples modos de uso intuitivos
- ‚úÖ **Calidad t√©cnica:** C√≥digo bien documentado y estructurado

### **12.2 Valor Educativo**
El proyecto demuestra ser una herramienta valiosa para:
- **Comprensi√≥n conceptual** de algoritmos de b√∫squeda
- **An√°lisis comparativo** de eficiencia algor√≠tmica
- **Experimentaci√≥n pr√°ctica** con heur√≠sticas
- **Aprendizaje interactivo** de estructuras de datos

### **12.3 Impacto T√©cnico**
- **Implementaci√≥n correcta** de algoritmos cl√°sicos
- **Heur√≠sticas matem√°ticamente v√°lidas** y optimizadas
- **Arquitectura extensible** para futuras mejoras
- **C√≥digo educativo** con documentaci√≥n exhaustiva

El **Sistema Interactivo de Algoritmos de Pathfinding** representa una contribuci√≥n significativa al aprendizaje de inteligencia artificial, combinando rigor t√©cnico con accesibilidad educativa.

---

**Memoria Descriptiva - Versi√≥n 1.0**  
**Fecha:** Septiembre 2025  
**Autor:** Proyecto Juego_Carrera_IA  
**Repositorio:** https://github.com/Nicols7A4/Juego_Carrera_IA